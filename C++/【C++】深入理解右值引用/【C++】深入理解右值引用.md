## 1. 左值和右值

首先来介绍一下左值和右值的区别，内容参考于《C++ primer 5th》p121。

**当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。**（受对象用途影响）

原则：在需要右值的地方可以用左值代替，但是不能把右值当成左值使用（对象移动除外）。当一个左值代替右值使用时，实际使用的是它的内容（值）。

在C++中，不能单纯的说，左值可以位于赋值语句的左侧，但右值不可以。如：以常量对象为代表的某些左值并不能作为赋值语句的左侧运算对象。例：

```c++
const int MAX_LEN = 10; // MAX_LEN是左值
MAX_LEN = 5;            // 错误：试图向const对象赋值。 左值不能位于赋值语句的左侧。
```

网络上有一种说法，左值位于赋值语句的左侧，右值位于右侧（这句话不是相对于变量说的）。例：

```c++
int a = 1;    // a是左值（在内存中的位置）， 1是右值（内容），不能给1赋值
int y = a;    // 用左值代替右值，把内容赋值给y。a依然是左值，可以取地址。但是在该表达式中，左值代替右值使用，所以赋值语句右边也可以说是右值，只不过是a的内容。
```

用到左值的运算符：

- 赋值运算符需要一个（非常量）左值作为其运算对象，得到的结果也仍然是一个左值。
- 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值（无法放到赋值语句的左侧，进行赋值）。
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vertor的下标运算符。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。

总结：常量、有地址的变量一定是左值，临时值是右值。左值可以当成右值用。

## 2. 左值引用

左值引用：引用是变量的别名，指向左值。但const左值引用除外，由于const的不可变性，所以const引用可以指向右值，我们经常使用const引用作为函数参数传递。例：

```
int a = 1;    
int &b = a;			// 正确
int &c = 10;		// 错误：10是右值。
const int &d = 10;  // 正确 
```

左值引用可以参考我的另一篇文章：https://zhuanlan.zhihu.com/p/390611356

## 3. 右值引用

内容参考于《C++ primer 5th》p471。

### 3.1 出现

在重新分配内存的过程中，从旧元素将元素拷贝到新内存是不必要的，更好的方式是移动元素。还有一些可以移动但不能拷贝的类，如：IO类和unique_ptr类。索所以，为了支持移动操作，新标准引入了一种新的引用类型——**右值引用**。

## 3.2 概念

右值引用：必须绑定到右值的引用，且**只能绑定到一个将要销毁的对象**。所以，可以自由地将一个右值引用地资源“移动”到另一个对象中。通过&&获得右值引用（左值引用是&）。例：

```c++
int a = 1;
int &b = a;   			// 正确：左值引用，a是左值
int &&C = a;  			// 错误：右值引用，不能绑定到一个左值上
int &d = a*3; 			// 错误：左值引用，a*3是右值
const int &e = a*3; 	// 正确：左值引用，const引用可以绑定到一个右值上
int &&f = a*3;     		// 正确：右值引用，a*3是右值
int &&g = 10;			// 正确：右值引用，10是右值
```

变量表达式是左值，例：

```c++
int &&a = 10;   // 正确：10是右值
int &&b = a; 	// 错误：即使a是右值引用，但a依然是左值，a不是临时对象
```

## 3.3 特性

从上面的例子，可以看到：左值引用有持久的状态；右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

由于右值引用只能绑定到临时对象，所以：

- 所引用的对象将要被销毁
- 该对象没有其他用户。

而且，使用右值的代码可以自由地接管所引用地对象的资源。

## 3.4 std::move





















## 概念

## 底层实现

### 与原变量绑定

### 引用占内存吗？

### 只可被绑定一次

## 使用场景

## 引用和指针的区别

## 总结





### 左值、 纯右值、将亡值

- 左值和将亡值合称泛左值，纯右值和将亡值合称右值。

### std::move的作用

- [c++ 之 std::move 原理实现与用法总结](https://blog.csdn.net/p942005405/article/details/84644069/)

- 避免不必要的拷贝操作

- std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。

- 对一个字符串只调用std::move，前面没有接收的情况下调用后这个字符串的内容

  -  所有权不变

- 对一个字符串调用std::move，前面有字符串对象接收调用后这个字符串的内容

  - 所有权转变

- unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。

```c++
		//auto* pData1 = new int;
    	std::string s1 = "hello";
    	std::string s2 = "world";
    	// s1:hello    s2:world
    	s2 = std::move(s1);
    	// s1:     s2:hello
    	s2 = "work";
    	// s1:     s2:work
    	s1 = "study";
    	// s1:study     s2:work
    	std::move(s1);
    	// s1:study    s2:world
    	s1 = "end1";
    	s2 = "end2";
    	// s1:end1    s2:end2
```



指针引用 博客